# 极简博客
一、linux操作系统

1、基本命令：列举几个常用命令以及功能，如pwd、cd、top、mkdir、touch、rm

回答下面命令的含义

ps/sort/awk/join/pwd/iostat/vmstat/top/kill

2、什么是死锁？其条件是什么？怎样避免死锁？

　　死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。

　　死锁产生的原因主要是：

   （1）系统资源不足；（2）进程推进顺序非法。

　　产生死锁的必要条件：

　　（1）互斥（mutualexclusion），一个资源每次只能被一个进程使用；

　　（2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；

　　（3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；

　　（4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。

　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

　　死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源 的分配要给予合理的规划。

 

二、数据库：mysql

1、MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义
(1)、varchar与char的区别
char是一种固定长度的类型，varchar则是一种可变长度的类型
(2)、varchar(50)中50的涵义
最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)
(3)、int（20）中20的涵义
是指显示字符的长度
但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0
20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；
(4)、mysql为什么这么设计
对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；

2、表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问
(1)、您是选择拆成子表，还是继续放一起；
(2)、写出您这样选择的理由。
答：拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；
如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗
如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择

 

3、索引的工作原理和种类，为什么要使用索引？

数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。

创建索引可以大大提高系统的性能。

第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。

第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

 

4、mysql基本命令

列出数据库：show databases;

选择数据库：use databaseName;

列出表格：show tables；

显示表格列的属性：show columns from tableName；

建立数据库：source fileName.txt;

匹配字符：可以用通配符_代表任何一个字符，％代表任何字符串;

增加一个字段：alter table tabelName add column fieldName dateType;

增加多个字段：alter table tabelName add column fieldName1 dateType,add columns fieldName2 dateType;

limit(选出10到20条)<第一个记录集的编号是0> ： select * from students order by id limit 9,10;

更新一条记录 update table set a=xxx where b=xxx；

 

三、java

1、Java语言支持的8中基本数据类型是：

byte

short

int

long

float

double

boolean

char

2、Java集合类框架的基本接口有哪些？

集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。

Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：

Collection：代表一组对象，每一个对象都是它的子元素。

Set：不包含重复元素的Collection。

List：有顺序的collection，并且可以包含重复元素。

Map：可以把键(key)映射到值(value)的对象，键不能重复。

3、Java中的HashMap的工作原理是什么？

Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。

HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。

4、简述this关键字用法。

a) this关键字使用在实例方法中，代表调用该方法的当前对象。

5. final关键字可以用来修饰什么？分别起什么作用？

a) final可以修饰类，这样的类不能被继承。

b) final可以修饰方法，这样的方法不能被重写。

c) final可以修饰变量，这样的变量的值不能被修改，是常量。

6. 简述super关键字作用？

a) 使用super调用父类的构造方法。

b) 使用super操作被隐藏的成员变量和方法。

 

四、编程 & 算法

详细介绍个人做过最好的项目的技术架构，实现方式和细节，碰到的难点【10分】

       2. 假如有个list，包含1-10000000的数字，少了2个数，如何找出这两个数，如果内存只有1k的情况下呢？【10分】

参考答案：

1. 开辟一个位图，第一次遍历设置下标，第二次遍历找没有设置下标的，没有下标的即是该数字。O(2n)。【答对给4分】

2. 计算和与平方和：【答对给6分】
1+2+…+10000
1^2+2^2+…+10000^2
以上两个数字为常数
根据list，计算x+y和x^2+y^2，再计算x,y
时间复杂度O(n)

       3. 编程：

1.输入一个正数n，输出所有和为n的连续正数序列。

分析：设定两个指针，min指向和为n的连续正数序列的最小值，max指向和为n的连续正数序列最大值。sum表示真正的和。

初始情况下,min、max和sum 都指向1.

当sum小于n时，max++；

当sum大于n时，min++;

当sum等于n时，输出整个序列。

public class a {
public static void getAns(int n) {
    int min = 1;
    int sum = 1;
    int max = 1;
    while(min <= n/2+1) {
        if(sum == n) {
            for(int k = min; k<=max; k++) {         
            System.out.println(k+"");
            }
            System.out.println();
            sum = sum - min;
            min ++;
            max ++;
            sum = sum+max;
        }
        if(sum > n) {
            sum = sum - min;
            min ++;
        } else {
            max ++;
            sum = sum + max;
        }
    }
}
public static void main(String[] args) {
    getAns(15);
}}
